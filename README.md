1. Answer: var, let, and const are all JavaScript keywords used to declare variables, but they differ in terms of scope, hoisting, and reassignment capabilities. Variables declared with var have function scope or global scope, are hoisted with an initial value of undefined, and can be both redeclared and reassigned. In contrast, let and const were introduced in ES6 and are block-scoped, meaning their visibility is limited to the code block ({}) in which they are defined. While let allows for reassignment, it prevents redeclaration in the same scope. The key difference is that const is used for variables whose values should not change. It prevents both reassignment and redeclaration, though the properties of an object or the elements of an array declared with const can still be modified. Modern JavaScript development strongly favors let and const over var due to their more predictable and controlled behavior, which helps prevent common bugs.

2. Answer: map(), forEach(), and filter() are all JavaScript array methods, but they serve different purposes. The map() method creates a new array by calling a provided function on every element in the original array, making it ideal for transforming data. In contrast, the forEach() method simply executes a function for each array element without creating a new array, and is used for side effects like printing to the console or modifying an external variable. Lastly, the filter() method creates a new array containing only the elements that pass a test implemented by a given function, making it perfect for selecting a subset of elements. While both map() and filter() always return a new array, forEach() returns undefined.

3. Answer: Arrow functions, introduced in ES6, provide a concise way to write anonymous functions. Their syntax (parameters) => expression is shorter than traditional function expressions and allows for an implicit return if the function body consists of a single expression. A key difference lies in their handling of the this keyword: arrow functions do not have their own this binding; instead, they inherit it from the parent scope. This lexical this binding resolves a common problem in JavaScript, making them ideal for use as callbacks within methods or objects where preserving the surrounding context is crucial. However, arrow functions cannot be used as constructors and do not have their own arguments object.

4. Answer: Destructuring assignment in ES6 is a powerful feature that allows you to extract values from arrays or properties from objects and assign them to variables in a single, concise expression. It works by using a syntax that mirrors array and object literals on the left-hand side of the assignment. For arrays, you use square brackets [] to specify the variables that will receive the values based on their position (e.g., let [a, b] = [1, 2]; assigns 1 to a and 2 to b). For objects, you use curly braces {} to specify the properties you want to extract by name (e.g., let {name, age} = person; assigns the name and age properties of the person object to new variables with the same names). This method simplifies code, reduces verbosity, and makes it easier to work with data structures, especially when dealing with function parameters and return values.

5. Answer: Template literals, introduced in ES6, are a modern way to create strings in JavaScript using backticks (``). They allow for embedded expressions and multi-line strings without the need for special characters. The syntax ${expression} within the backticks enables you to insert variables, arithmetic operations, or function calls directly into the string, which is a significant improvement over traditional string concatenation. The key difference from concatenation is that template literals offer a more readable and cleaner syntax. Instead of manually joining strings with the + operator, which can become messy and error-prone, you can simply write the string with placeholders for dynamic content. For example, instead of 'Hello, ' + name + '!', you can write `Hello, ${name}!`. This enhances code clarity and reduces the chance of errors, especially with complex strings.
