`var`, `let`, and `const` are all JavaScript keywords used to declare variables, but they differ in their **scope**, **hoisting**, and **reassignment capabilities**. Variables declared with **`var`** have a function scope or global scope, are hoisted with an initial value of `undefined`, and can be both redeclared and reassigned. In contrast, **`let`** and **`const`** were introduced in ES6 and are block-scoped, meaning their visibility is limited to the code block (`{}`) they are defined within. While `let` allows for reassignment, it prevents redeclaration in the same scope. The key difference is that **`const`** is used for variables whose values should not change; it prevents both reassignment and redeclaration, though the properties of an object or elements of an array declared with `const` can still be modified. Modern JavaScript development strongly favors `let` and `const` over `var` due to their more predictable and controlled behavior, which helps prevent common bugs.
`map()`, `forEach()`, and `filter()` are all JavaScript array methods, but they serve different purposes. The **`map()`** method creates a new array by calling a provided function on every element in the original array, making it ideal for **transforming** data. In contrast, the **`forEach()`** method simply executes a function for each array element without creating a new array, and is used for **side effects** like printing to the console or modifying an external variable. Lastly, the **`filter()`** method creates a new array containing only the elements that pass a test implemented by a given function, making it perfect for **selecting** a subset of elements. While `map()` and `filter()` always return a new array, `forEach()` returns `undefined`.
Arrow functions, introduced in ES6, provide a concise way to write anonymous functions. Their syntax `(parameters) => expression` is shorter than traditional function expressions and allows for an implicit return if the function body is a single expression. A key difference lies in their handling of the `this` keyword: arrow functions do not have their own `this` binding, instead inheriting it from the parent scope. This **lexical `this` binding** solves a common problem in JavaScript, making them ideal for use as callbacks within methods or objects where preserving the surrounding context is crucial. However, they cannot be used as constructors and do not have their own `arguments` object.
Destructuring assignment in ES6 is a powerful feature that allows you to extract values from arrays or properties from objects and assign them to variables in a single, concise expression. It works by using a syntax that mirrors array and object literals on the left-hand side of the assignment. For arrays, you use square brackets `[]` to specify the variables that will receive the values based on their position (e.g., `let [a, b] = [1, 2];` assigns `1` to `a` and `2` to `b`). For objects, you use curly braces `{}` to specify the properties you want to extract by name (e.g., `let {name, age} = person;` assigns the `name` and `age` properties of the `person` object to new variables with the same names). This method simplifies code, reduces verbosity, and makes it easier to work with data structures, especially when dealing with function parameters and return values.
Template literals, introduced in ES6, are a modern way to create strings in JavaScript using **backticks** (` `` `). They allow for **embedded expressions** and **multi-line strings** without using special characters. The syntax `$ {expression}` within the backticks allows you to insert variables, arithmetic operations, or function calls directly into the string, which is a significant improvement over traditional string concatenation. The key difference from concatenation is that template literals offer a more readable and cleaner syntax. Instead of manually joining strings with the `+` operator, which can become messy and error-prone, you can simply write the string with placeholders for dynamic content. For example, instead of `'Hello, ' + name + '!'`, you can write ` `Hello, ${name}!``. This improves code clarity and reduces the chance of errors, especially with complex strings.
